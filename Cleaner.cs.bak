using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace WindowsCleaner
{
    /// <summary>
    /// Configuration des options de nettoyage du système
    /// </summary>
    public class CleanerOptions
    {
        /// <summary>Effectue un nettoyage de simulation sans supprimer de fichiers</summary>
        public bool DryRun { get; set; }
        /// <summary>Vide la Corbeille</summary>
        public bool EmptyRecycleBin { get; set; }
        /// <summary>Inclut le nettoyage du répertoire Temp système (nécessite admin)</summary>
        public bool IncludeSystemTemp { get; set; }
        /// <summary>Nettoie les caches des navigateurs web</summary>
        public bool CleanBrowsers { get; set; }
        /// <summary>Nettoie le cache Windows Update (nécessite admin)</summary>
        public bool CleanWindowsUpdate { get; set; }
        /// <summary>Nettoie les fichiers de vignettes</summary>
        public bool CleanThumbnails { get; set; }
        /// <summary>Nettoie le répertoire Prefetch (nécessite admin)</summary>
        public bool CleanPrefetch { get; set; }
        /// <summary>Exécute le flush DNS</summary>
        public bool FlushDns { get; set; }
        /// <summary>Affiche les messages de log détaillés</summary>
        public bool Verbose { get; set; }
        
        // Advanced options
        /// <summary>Nettoie les journaux système (désactivé par défaut - risqué)</summary>
        public bool CleanSystemLogs { get; set; }
        /// <summary>Nettoie le cache des installateurs (désactivé par défaut - risqué)</summary>
        public bool CleanInstallerCache { get; set; }
        /// <summary>Nettoie les fichiers orphelins datant de plus de 7 jours</summary>
        public bool CleanOrphanedFiles { get; set; }
        /// <summary>Nettoie les journaux des applications (désactivé par défaut - risqué)</summary>
        public bool CleanApplicationLogs { get; set; }
        /// <summary>Vide le cache mémoire via GC</summary>
        public bool ClearMemoryCache { get; set; }
    }

    /// <summary>
    /// Résultat du nettoyage contenant les statistiques
    /// </summary>
    public class CleanerResult
    {
        /// <summary>Nombre de fichiers supprimés</summary>
        public int FilesDeleted { get; set; }
        /// <summary>Nombre d'octets libérés</summary>
        public long BytesFreed { get; set; }
    }

    /// <summary>
    /// Élément du rapport de nettoyage
    /// </summary>
    public class ReportItem
    {
        /// <summary>Chemin du fichier ou dossier</summary>
        public string Path { get; set; } = string.Empty;
        /// <summary>Taille en octets</summary>
        public long Size { get; set; }
        /// <summary>Indique si c'est un répertoire</summary>
        public bool IsDirectory { get; set; }
    }

    /// <summary>
    /// Rapport complet de nettoyage avec tous les éléments trouvés
    /// </summary>
    public class CleanerReport
    {
        /// <summary>Liste des éléments à nettoyer</summary>
        public System.Collections.Generic.List<ReportItem> Items { get; } = new System.Collections.Generic.List<ReportItem>();
        /// <summary>Total d'octets trouvés</summary>
        public long TotalBytes => Items.Sum(i => i.Size);
        /// <summary>Nombre d'éléments trouvés</summary>
        public int Count => Items.Count;
    }

    /// <summary>
    /// Classe principale pour exécuter les opérations de nettoyage système
    /// </summary>
    public static class Cleaner
    {
        [DllImport("Shell32.dll", CharSet = CharSet.Unicode)]
        private static extern int SHEmptyRecycleBin(IntPtr hwnd, string? pszRootPath, uint dwFlags);

        // Flags for SHEmptyRecycleBin
        private const uint SHERB_NOCONFIRMATION = 0x00000001;
        private const uint SHERB_NOPROGRESSUI = 0x00000002;
        private const uint SHERB_NOSOUND = 0x00000004;

        /// <summary>
        /// Exécute le nettoyage selon les options spécifiées
        /// </summary>
        /// <param name="options">Configuration des opérations à effectuer</param>
        /// <param name="log">Délégué optionnel pour recevoir les messages de log</param>
        /// <param name="cancellationToken">Token pour annuler l'opération</param>
        /// <returns>Résultat du nettoyage avec statistiques</returns>
        public static CleanerResult RunCleanup(CleanerOptions options, Action<string>? log = null, CancellationToken cancellationToken = default)
        {
            var result = new CleanerResult();
            var lockObj = new object();

            // Thread-safe logger wrapper
            Action<string> threadSafeLog = CreateThreadSafeLogger(options.Verbose, log);

            void AddResult(int files, long bytes)
            {
                lock (lockObj)
                {
                    result.FilesDeleted += files;
                    result.BytesFreed += bytes;
                }
            }

            var tasks = new System.Collections.Generic.List<Task>();

            // User temp
            tasks.Add(Task.Run(() =>
            {
                try
                {
                    string userTemp = BrowserPaths.UserTemp;
                    threadSafeLog($"Nettoyage du dossier temporaire utilisateur: {userTemp}");
                    var r = DeleteDirectoryContents(userTemp, options.DryRun, threadSafeLog, cancellationToken);
                    AddResult(r.files, r.bytes);
                }
                catch (Exception ex)
                {
                    Logger.Log(LogLevel.Error, $"Erreur nettoyage user temp: {ex.Message}");
                }
            }, cancellationToken));

            // LocalAppData\Temp
            tasks.Add(Task.Run(() =>
            {
                try
                {
                    var localTemp = BrowserPaths.LocalAppDataTemp;
                    threadSafeLog($"Nettoyage du dossier LocalAppData Temp: {localTemp}");
                    var r = DeleteDirectoryContents(localTemp, options.DryRun, threadSafeLog, cancellationToken);
                    AddResult(r.files, r.bytes);
                }
                catch (Exception ex)
                {
                    Logger.Log(LogLevel.Error, $"Erreur nettoyage LocalAppData Temp: {ex.Message}");
                }
            }, cancellationToken));

            // System temp (optional)
            if (options.IncludeSystemTemp)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var systemTemp = BrowserPaths.SystemTemp;
                        threadSafeLog($"Nettoyage du dossier Temp système: {systemTemp}");
                        var r = DeleteDirectoryContents(systemTemp, options.DryRun, threadSafeLog, cancellationToken);
                        AddResult(r.files, r.bytes);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage System Temp: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Browser caches (Chrome, Edge, Firefox)
            if (options.CleanBrowsers)
            {
                // Chrome cache
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!Directory.Exists(BrowserPaths.ChromeCache)) return;
                        threadSafeLog($"Nettoyage cache Chrome: {BrowserPaths.ChromeCache}");
                        var r = DeleteDirectoryContents(BrowserPaths.ChromeCache, options.DryRun, threadSafeLog, cancellationToken);
                        AddResult(r.files, r.bytes);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage Chrome: {ex.Message}");
                    }
                }, cancellationToken));

                // Edge cache
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!Directory.Exists(BrowserPaths.EdgeCache)) return;
                        threadSafeLog($"Nettoyage cache Edge: {BrowserPaths.EdgeCache}");
                        var r = DeleteDirectoryContents(BrowserPaths.EdgeCache, options.DryRun, threadSafeLog, cancellationToken);
                        AddResult(r.files, r.bytes);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage Edge: {ex.Message}");
                    }
                }, cancellationToken));

                // Firefox cache
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!BrowserPaths.IsFirefoxInstalled) return;
                        threadSafeLog($"Nettoyage cache Firefox: {BrowserPaths.FirefoxProfiles}");
                        var profiles = Directory.GetDirectories(BrowserPaths.FirefoxProfiles);
                        foreach (var profile in profiles)
                        {
                            var cacheDir = BrowserPaths.GetFirefoxCache(profile);
                            if (Directory.Exists(cacheDir))
                            {
                                var r = DeleteDirectoryContents(cacheDir, options.DryRun, threadSafeLog, cancellationToken);
                                AddResult(r.files, r.bytes);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage Firefox: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Windows Update cache (SoftwareDistribution) - requires admin
            if (options.CleanWindowsUpdate)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var sd = BrowserPaths.WindowsUpdateCache;
                        threadSafeLog($"Nettoyage SoftwareDistribution\\Download: {sd}");
                        var r = DeleteDirectoryContents(sd, options.DryRun, threadSafeLog, cancellationToken);
                        AddResult(r.files, r.bytes);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage SoftwareDistribution: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Thumbnails
            if (options.CleanThumbnails)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var thumbDir = BrowserPaths.ThumbnailsCache;
                        threadSafeLog($"Nettoyage vignettes: {thumbDir}");
                        var files = Directory.Exists(thumbDir) ? Directory.GetFiles(thumbDir, "thumbcache_*.db") : Array.Empty<string>();
                        int filesDeleted = 0;
                        long bytesFreed = 0;
                        foreach (var f in files)
                        {
                            try
                            {
                                var fi = new FileInfo(f);
                                if (!options.DryRun) File.Delete(f);
                                filesDeleted++;
                                bytesFreed += fi.Length;
                                threadSafeLog($"Supprimé vignette: {f}");
                            }
                            catch (Exception ex)
                            {
                                threadSafeLog($"Impossible de supprimer vignette {f}: {ex.Message}");
                            }
                        }
                        AddResult(filesDeleted, bytesFreed);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage vignettes: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Prefetch (requires admin)
            if (options.CleanPrefetch)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var prefetch = BrowserPaths.Prefetch;
                        threadSafeLog($"Nettoyage Prefetch: {prefetch}");
                        var r = DeleteDirectoryContents(prefetch, options.DryRun, threadSafeLog, cancellationToken);
                        AddResult(r.files, r.bytes);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage Prefetch: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Advanced: System logs
            if (options.CleanSystemLogs)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        // WARNING: Deleting system event logs can cause Windows instability
                        threadSafeLog("⚠️ Nettoyage des journaux système désactivé (risque de crash système)");
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage journaux système: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Advanced: Installer cache
            if (options.CleanInstallerCache)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        // WARNING: Windows\\Installer directory contains critical MSI files
                        threadSafeLog("⚠️ Nettoyage du cache installeur désactivé (risque de crash/dysfonctionnement)");
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage cache installeur: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Advanced: Application logs
            if (options.CleanApplicationLogs)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        // WARNING: Application logs in LocalState can be used by system services
                        threadSafeLog("⚠️ Nettoyage des journaux applications désactivé (risque de dysfonctionnement)");
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage journaux applications: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Advanced: Orphaned files (temp files without extensions or specific patterns)
            if (options.CleanOrphanedFiles)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var userTemp = BrowserPaths.UserTemp;
                        threadSafeLog($"Nettoyage fichiers orphelins: {userTemp}");
                        var orphanFiles = Directory.GetFiles(userTemp, "*.*", SearchOption.TopDirectoryOnly)
                            .Where(f => new FileInfo(f).CreationTime < DateTime.Now.AddDays(-7)).ToList();
                        
                        int deleted = 0;
                        long freed = 0;
                        foreach (var file in orphanFiles)
                        {
                            try
                            {
                                var fi = new FileInfo(file);
                                if (!options.DryRun) File.Delete(file);
                                deleted++;
                                freed += fi.Length;
                                threadSafeLog($"Supprimé fichier orphelin: {Path.GetFileName(file)}");
                            }
                            catch (Exception ex)
                            {
                                threadSafeLog($"Impossible de supprimer {file}: {ex.Message}");
                            }
                        }
                        AddResult(deleted, freed);
                    }
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur nettoyage fichiers orphelins: {ex.Message}");
                    }
                }, cancellationToken));
            }

            // Wait for all tasks to complete
            try
            {
                Task.WaitAll(tasks.ToArray(), cancellationToken);
            }
            catch (OperationCanceledException)
            {
                threadSafeLog("Nettoyage annulé par l'utilisateur");
            }

            // Clear memory cache (requires admin)
            if (options.ClearMemoryCache)
            {
                try
                {
                    threadSafeLog("Nettoyage du cache mémoire système...");
                    if (!options.DryRun)
                    {
                        // Safe memory cache clearing using GC only
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        GC.Collect();
                        
                        threadSafeLog("Cache mémoire nettoyé avec succès");
                    }
                    else
                    {
                        threadSafeLog("(dry-run) Cache mémoire non nettoyé");
                    }
                }
                catch (Exception ex)
                {
                    Logger.Log(LogLevel.Error, $"Erreur nettoyage cache mémoire: {ex.Message}");
                }
            }

            // Flush DNS (sequential, quick operation)
            if (options.FlushDns)
            {
                try
                {
                    threadSafeLog("Exécution flush DNS...");
                    if (!options.DryRun)
                    {
                        var psi = new System.Diagnostics.ProcessStartInfo("ipconfig", "/flushdns") { CreateNoWindow = true, UseShellExecute = false };
                        var p = System.Diagnostics.Process.Start(psi);
                        p?.WaitForExit(5000);
                    }
                    else
                    {
                        threadSafeLog("(dry-run) ipconfig /flushdns non exécuté");
                    }
                }
                catch (Exception ex)
                {
                    Logger.Log(LogLevel.Error, $"Erreur flush DNS: {ex.Message}");
                }
            }

            // Empty Recycle Bin (sequential, requires UI thread in some cases)
            if (options.EmptyRecycleBin)
            {
                try
                {
                    threadSafeLog("Vidage de la Corbeille...");
                    if (!options.DryRun)
                    {
                        uint flags = SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND;
                        SHEmptyRecycleBin(IntPtr.Zero, null, flags);
                    }
                    else
                    {
                        threadSafeLog("(dry-run) Corbeille non vidée");
                    }
                }
                catch (Exception ex)
                {
                    Logger.Log(LogLevel.Error, $"Erreur vidage Corbeille: {ex.Message}");
                }
            }

            return result;
        }

        /// <summary>
        /// Génère un rapport détaillé des fichiers qui seraient nettoyés
        /// </summary>
        /// <param name="options">Configuration de scan</param>
        /// <param name="progress">Délégué optionnel pour recevoir les messages de progression</param>
        /// <param name="cancellationToken">Token pour annuler l'opération</param>
        /// <returns>Rapport contenant tous les éléments trouvés</returns>
        public static CleanerReport GenerateReport(CleanerOptions options, Action<string>? progress = null, CancellationToken cancellationToken = default)
        {
            var report = new CleanerReport();
            var items = new ConcurrentBag<ReportItem>();

            void P(string s) => progress?.Invoke(s);

            var tasks = new System.Collections.Generic.List<Task>();

            tasks.Add(Task.Run(() =>
            {
                try
                {
                    string userTemp = BrowserPaths.UserTemp;
                    P($"Scan du dossier temporaire utilisateur: {userTemp}");
                    ScanDirectoryParallel(userTemp, items, P, cancellationToken);
                }
                catch (Exception ex) 
                { 
                    Logger.Log(LogLevel.Error, $"Erreur scan user temp: {ex.Message}"); 
                }
            }, cancellationToken));

            tasks.Add(Task.Run(() =>
            {
                try
                {
                    var localTemp = BrowserPaths.LocalAppDataTemp;
                    P($"Scan LocalAppData Temp: {localTemp}");
                    ScanDirectoryParallel(localTemp, items, P, cancellationToken);
                }
                catch (Exception ex) 
                { 
                    Logger.Log(LogLevel.Error, $"Erreur scan LocalAppData Temp: {ex.Message}"); 
                }
            }, cancellationToken));

            if (options.IncludeSystemTemp)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var systemTemp = BrowserPaths.SystemTemp;
                        P($"Scan Temp système: {systemTemp}");
                        ScanDirectoryParallel(systemTemp, items, P, cancellationToken);
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan System Temp: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            if (options.CleanBrowsers)
            {
                // Chrome
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!Directory.Exists(BrowserPaths.ChromeCache)) return;
                        P($"Scan cache Chrome: {BrowserPaths.ChromeCache}");
                        ScanDirectoryParallel(BrowserPaths.ChromeCache, items, P, cancellationToken);
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan Chrome: {ex.Message}"); 
                    }
                }, cancellationToken));

                // Edge
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!Directory.Exists(BrowserPaths.EdgeCache)) return;
                        P($"Scan cache Edge: {BrowserPaths.EdgeCache}");
                        ScanDirectoryParallel(BrowserPaths.EdgeCache, items, P, cancellationToken);
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan Edge: {ex.Message}"); 
                    }
                }, cancellationToken));

                // Firefox
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (!BrowserPaths.IsFirefoxInstalled) return;
                        P($"Scan cache Firefox: {BrowserPaths.FirefoxProfiles}");
                        var profiles = Directory.GetDirectories(BrowserPaths.FirefoxProfiles);
                        foreach (var profile in profiles)
                        {
                            var cacheDir = BrowserPaths.GetFirefoxCache(profile);
                            if (Directory.Exists(cacheDir))
                            {
                                ScanDirectoryParallel(cacheDir, items, P, cancellationToken);
                            }
                        }
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan Firefox: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            if (options.CleanWindowsUpdate)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var sd = BrowserPaths.WindowsUpdateCache;
                        P($"Scan SoftwareDistribution\\Download: {sd}");
                        ScanDirectoryParallel(sd, items, P, cancellationToken);
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan SoftwareDistribution: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            if (options.CleanThumbnails)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var thumbDir = BrowserPaths.ThumbnailsCache;
                        P($"Scan vignettes: {thumbDir}");
                        if (Directory.Exists(thumbDir))
                        {
                            foreach (var f in Directory.GetFiles(thumbDir, "thumbcache_*.db"))
                            {
                                try 
                                { 
                                    var fi = new FileInfo(f);
                                    items.Add(new ReportItem { Path = f, Size = fi.Length, IsDirectory = false }); 
                                }
                                catch (Exception ex)
                                {
                                    Logger.Log(LogLevel.Error, $"Erreur lecture vignette {f}: {ex.Message}");
                                }
                            }
                        }
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan vignettes: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            if (options.CleanPrefetch)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var prefetch = BrowserPaths.Prefetch;
                        P($"Scan Prefetch: {prefetch}");
                        ScanDirectoryParallel(prefetch, items, P, cancellationToken);
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan Prefetch: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            if (options.CleanOrphanedFiles)
            {
                tasks.Add(Task.Run(() =>
                {
                    try
                    {
                        var userTemp = BrowserPaths.UserTemp;
                        P($"Scan fichiers orphelins: {userTemp}");
                        var orphanFiles = Directory.GetFiles(userTemp, "*.*", SearchOption.TopDirectoryOnly)
                            .Where(f => new FileInfo(f).CreationTime < DateTime.Now.AddDays(-7)).ToList();
                        foreach (var f in orphanFiles)
                        {
                            try 
                            { 
                                var fi = new FileInfo(f);
                                items.Add(new ReportItem { Path = f, Size = fi.Length, IsDirectory = false }); 
                            }
                            catch (Exception ex)
                            {
                                Logger.Log(LogLevel.Error, $"Erreur lecture fichier orphelin {f}: {ex.Message}");
                            }
                        }
                    }
                    catch (Exception ex) 
                    { 
                        Logger.Log(LogLevel.Error, $"Erreur scan fichiers orphelins: {ex.Message}"); 
                    }
                }, cancellationToken));
            }

            // Wait for all parallel scans to complete
            try
            {
                Task.WaitAll(tasks.ToArray(), cancellationToken);
            }
            catch (OperationCanceledException)
            {
                P("Scan du rapport annulé par l'utilisateur");
            }

            // Add all items to the report
            foreach (var item in items)
            {
                report.Items.Add(item);
            }

            if (options.EmptyRecycleBin)
            {
                P("Note: la Corbeille sera vidée (taille non estimée)");
            }

            return report;
        }

        /// <summary>
        /// Crée un logger thread-safe qui respecte le flag verbose
        /// </summary>
        private static Action<string> CreateThreadSafeLogger(bool verbose, Action<string>? log)
        {
            if (!verbose) return _ => { };
            
            var lockObj = new object();
            return msg =>
            {
                lock (lockObj)
                {
                    log?.Invoke(msg);
                }
            };
        }

        /// <summary>
        /// Scanne un répertoire de manière parallèle et remplit le bag d'éléments
        /// </summary>
        private static void ScanDirectoryParallel(string path, ConcurrentBag<ReportItem> items, Action<string>? progress, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(path) || !Directory.Exists(path)) return;
            try
            {
                Parallel.ForEach(Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories), 
                    new ParallelOptions { CancellationToken = cancellationToken },
                    f =>
                    {
                        try 
                        { 
                            var fi = new FileInfo(f);
                            items.Add(new ReportItem { Path = f, Size = fi.Length, IsDirectory = false }); 
                        }
                        catch (Exception ex)
                        {
                            Logger.Log(LogLevel.Error, $"Erreur lors du scan du fichier {f}: {ex.Message}");
                        }
                    });
                
                // Also add directories as items (size 0) for visibility
                Parallel.ForEach(Directory.EnumerateDirectories(path, "*", SearchOption.AllDirectories),
                    new ParallelOptions { CancellationToken = cancellationToken },
                    d =>
                    {
                        try 
                        { 
                            items.Add(new ReportItem { Path = d, Size = 0, IsDirectory = true }); 
                        }
                        catch (Exception ex)
                        {
                            Logger.Log(LogLevel.Error, $"Erreur lors du scan du répertoire {d}: {ex.Message}");
                        }
                    });
            }
            catch (Exception ex) 
            { 
                progress?.Invoke($"Erreur en scannant {path}: {ex.Message}");
                Logger.Log(LogLevel.Error, $"Erreur scan répertoire {path}: {ex.Message}");
            }
        }

        /// <summary>
        /// Supprime le contenu d'un répertoire de manière sécurisée
        /// </summary>
        private static (int files, long bytes) DeleteDirectoryContents(string path, bool dryRun, Action<string> log, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(path) || !Directory.Exists(path))
                return (0, 0);

            int deleted = 0;
            long bytes = 0;
            var lockObj = new object();

            try
            {
                var entries = Directory.GetFileSystemEntries(path);
                Parallel.ForEach(entries, new ParallelOptions { MaxDegreeOfParallelism = 4, CancellationToken = cancellationToken }, entry =>
                {
                    try
                    {
                        if (File.Exists(entry))
                        {
                            var (ok, freed) = TryDeleteFileWithRetries(entry, dryRun, log);
                            if (ok)
                            {
                                lock (lockObj)
                                {
                                    bytes += freed;
                                    deleted++;
                                }
                                log($"Supprimé: {entry}");
                            }
                        }
                        else if (Directory.Exists(entry))
                        {
                            var (ok, freed) = TryDeleteDirectoryWithRetries(entry, dryRun, log);
                            if (ok)
                            {
                                lock (lockObj)
                                {
                                    deleted++;
                                    bytes += freed;
                                }
                                log($"Supprimé dossier: {entry}");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        log($"Impossible de supprimer {entry}: {ex.Message}");
                        Logger.Log(LogLevel.Error, $"Erreur suppression {entry}: {ex.Message}");
                    }
                });
            }
            catch (Exception ex)
            {
                log($"Erreur en listant {path}: {ex.Message}");
                Logger.Log(LogLevel.Error, $"Erreur énumération {path}: {ex.Message}");
            }

            return (deleted, bytes);
        }

        /// <summary>
        /// Tente de supprimer un fichier avec retries en cas d'accès verrouillé
        /// </summary>
        private static (bool deleted, long bytesFreed) TryDeleteFileWithRetries(string filePath, bool dryRun, Action<string> log, int maxAttempts = 5)
        {
            if (!File.Exists(filePath)) return (false, 0);
            long size = 0;
            try
            {
                var fi = new FileInfo(filePath);
                size = fi.Length;
            }
            catch (Exception ex)
            {
                Logger.Log(LogLevel.Error, $"Impossible de lire la taille de {filePath}: {ex.Message}");
            }

            if (dryRun)
            {
                log($"(dry-run) Suppression planifiée: {filePath}");
                return (true, size);
            }

            int attempt = 0;
            var delay = 150;
            while (attempt < maxAttempts)
            {
                try
                {
                    File.Delete(filePath);
                    return (true, size);
                }
                catch (IOException ioEx)
                {
                    attempt++;
                    log($"Fichier verrouillé, tentative {attempt}/{maxAttempts}: {filePath}");
                    Thread.Sleep(delay);
                    delay *= 2;
                    continue;
                }
                catch (UnauthorizedAccessException ua)
                {
                    log($"Accès refusé à {filePath}");
                    Logger.Log(LogLevel.Error, $"Accès refusé: {ua.Message}");
                    return (false, 0);
                }
                catch (Exception ex)
                {
                    log($"Erreur suppression fichier {filePath}");
                    Logger.Log(LogLevel.Error, $"Erreur suppression {filePath}: {ex.Message}");
                    return (false, 0);
                }
            }

            log($"Échec suppression après {maxAttempts} tentatives: {filePath}");
            Logger.Log(LogLevel.Warning, $"Échec après {maxAttempts} tentatives: {filePath}");
            return (false, 0);
        }

        /// <summary>
        /// Tente de supprimer un répertoire avec retries en cas d'accès verrouillé
        /// </summary>
        private static (bool deleted, long bytesFreed) TryDeleteDirectoryWithRetries(string dirPath, bool dryRun, Action<string> log, int maxAttempts = 4)
        {
            if (!Directory.Exists(dirPath)) return (false, 0);

            long totalFreed = 0;
            try
            {
                // Try to calculate approximate size (sum of file lengths)
                foreach (var f in Directory.EnumerateFiles(dirPath, "*", SearchOption.AllDirectories))
                {
                    try { totalFreed += new FileInfo(f).Length; } 
                    catch (Exception ex)
                    {
                        Logger.Log(LogLevel.Error, $"Erreur calcul taille: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Log(LogLevel.Error, $"Erreur énumération taille {dirPath}: {ex.Message}");
            }

            if (dryRun)
            {
                log($"(dry-run) Suppression planifiée du dossier: {dirPath}");
                return (true, totalFreed);
            }

            int attempt = 0;
            var delay = 200;
            while (attempt < maxAttempts)
            {
                try
                {
                    Directory.Delete(dirPath, true);
                    return (true, totalFreed);
                }
                catch (IOException ioEx)
                {
                    attempt++;
                    log($"Dossier verrouillé, tentative {attempt}/{maxAttempts}: {dirPath}");
                    Thread.Sleep(delay);
                    delay *= 2;
                    continue;
                }
                catch (UnauthorizedAccessException ua)
                {
                    log($"Accès refusé au dossier {dirPath}");
                    Logger.Log(LogLevel.Error, $"Accès refusé dossier: {ua.Message}");
                    return (false, 0);
                }
                catch (Exception ex)
                {
                    log($"Erreur suppression dossier {dirPath}");
                    Logger.Log(LogLevel.Error, $"Erreur suppression dossier {dirPath}: {ex.Message}");
                    return (false, 0);
                }
            }

            log($"Échec suppression dossier après {maxAttempts} tentatives: {dirPath}");
            Logger.Log(LogLevel.Warning, $"Échec dossier après {maxAttempts} tentatives: {dirPath}");
            return (false, 0);
        }
    }
}
